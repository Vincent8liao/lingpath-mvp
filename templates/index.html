<!doctype html>
<html lang="zh">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Dictation MVP - Letter Grid</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; max-width: 960px; margin: 24px auto; padding: 0 16px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin: 12px 0; }
    button, select { padding: 10px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button:hover { background: #f6f6f6; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .muted { color: #666; }
    .small { font-size: 13px; }

    .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 12px; border: 1px solid #ddd; }
    .ok { background: #eaffea; border-color: #b7e3b7; }
    .wrong { background: #ffecec; border-color: #f1b6b6; }
    .miss { background: #f3f3f3; border-color: #dedede; }
    .extra { background: #eef4ff; border-color: #b7cdfc; }

    /* Letter grid */
    .grid{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      padding:12px;
      border:1px solid #ddd;
      border-radius:12px;
      min-height:64px;
      cursor:text;
      user-select:none;
      outline: none;
    }
    .cell{
      width:28px;
      height:34px;
      border:1px solid #ccc;
      border-radius:8px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:16px;
    }
    .cell.empty{ color:#bbb; }
    .cell.space{
      width:12px;
      border-color:transparent;
      background:transparent;
    }
    .cell.punc{
      border-color:#e6e6e6;
      background:#fafafa;
      color:#9a9a9a;
      font-weight: 600;
    }
    .cell.caret{
      outline:2px solid #111;
      outline-offset:1px;
    }

    .hidden-input{
      position:absolute;
      left:-9999px;
      width:1px;
      height:1px;
      opacity:0;
    }

    /* Result tokens */
    .tokens { line-height: 2.2; }
    .tok { padding: 3px 8px; border-radius: 999px; border: 1px solid transparent; display: inline-block; margin: 2px 4px 2px 0; }
    .tok.ok { border-color: #b7e3b7; }
    .tok.wrong { border-color: #f1b6b6; text-decoration: underline wavy #e25555; }
    .tok.missing { border-color: #dedede; opacity: 0.9; }
    .tok.extra { border-color: #b7cdfc; }

    .hidden { display: none; }
  </style>
</head>
<body>

  <h1>å¬å†™ç³»ç»Ÿ MVPï¼ˆ3 å…³å¡ + è®°å½•æˆç»© + æ ‡å‡†ç­”æ¡ˆé»˜è®¤éšè—ï¼‰</h1>

  <div class="card">
    <div class="row">
      <label class="small muted">é€‰æ‹©å…³å¡ï¼š</label>
      <select id="levelSelect"></select>

      <button id="btnPlay">â–¶ æ’­æ”¾ / é‡å¬</button>
      <button id="btnCheck">âœ… æ£€æŸ¥</button>
      <button id="btnClear">ğŸ§¹ æ¸…ç©º</button>
      <button id="btnToggleRef">ğŸ‘ æ˜¾ç¤ºæ ‡å‡†ç­”æ¡ˆ</button>
      <button id="btnReset" style="background:#ffecec;border-color:#f1b6b6;">
  ğŸ§¨ é‡ç½®å…³å¡è¿›åº¦
      </button>


      <span class="badge ok">correct</span>
      <span class="badge wrong">wrong</span>
      <span class="badge miss">missing</span>
      <span class="badge extra">extra</span>
    </div>
  </div> 
    <div class="small muted" style="margin-top:10px" id="levelMeta"></div>

    <audio id="audio" preload="auto"></audio>
  

  <div class="card">
    <h3>æ ‡å‡†ç­”æ¡ˆï¼ˆreference sentenceï¼‰</h3>
    <p id="referenceText" class="muted hidden" style="font-size:16px;"></p>
    <p class="small muted">
      è§„åˆ™ï¼šignore case + ignore punctuationï¼ˆæ£€æŸ¥æ—¶å¿½ç•¥å¤§å°å†™ä¸æ ‡ç‚¹ï¼‰ï¼›è¾“å…¥æ—¶è‡ªåŠ¨è·³è¿‡ç©ºæ ¼ï¼Œæ ‡ç‚¹è‡ªåŠ¨æ˜¾ç¤ºå ä½ã€‚
    </p>
  </div>

  <div class="card">
    <h3>ä½ çš„è¾“å…¥ï¼ˆtypingï¼šæ¯ä¸ªå­—æ¯ä¸€ä¸ªæ ¼å­ï¼‰</h3>
    <div id="letterGrid" class="grid" tabindex="0" aria-label="dictation letter grid"></div>
    <input id="hiddenInput" class="hidden-input" autocomplete="off" autocapitalize="off" spellcheck="false" />
    <p class="muted small" style="margin-top:10px;">
      ç”¨æ³•ï¼šç‚¹å‡»æ ¼å­åŒºåŸŸ â†’ ç›´æ¥æ‰“å­—ï¼›Backspace åˆ é™¤ï¼›ç©ºæ ¼ä¸ç”¨æ‰“ï¼›æ ‡ç‚¹ä¸ç”¨æ‰“ã€‚
    </p>
  </div>

  <div class="card">
    <h3>åˆ¤å®šç»“æœï¼ˆword-level feedbackï¼‰</h3>
    <div id="resultSummary" class="muted small"></div>
    <div id="resultTokens" class="tokens"></div>

    <hr style="border:none;border-top:1px solid #eee;margin:14px 0;" />

    <div class="muted small">
      <div><b>Reference tokens</b>ï¼ˆæ ‡å‡†ç­”æ¡ˆåˆ†è¯ï¼‰:</div>
      <div id="refTokensView"></div>
      <div style="margin-top:10px;"><b>User tokens</b>ï¼ˆä½ çš„è¾“å…¥åˆ†è¯ï¼‰:</div>
      <div id="userTokensView"></div>
    </div>
  </div>


<script>
  // -------------------------
  // 0) State
  // -------------------------
  const referenceTextEl = document.getElementById("referenceText");
  const levelSelect = document.getElementById("levelSelect");
  const levelMeta = document.getElementById("levelMeta");

  const letterGrid = document.getElementById("letterGrid");
  const hiddenInput = document.getElementById("hiddenInput");

  const audio = document.getElementById("audio");
  const STATIC_BASE = "{{ url_for('static', filename='') }}";
  document.getElementById("btnReset").addEventListener("click", async () => {
  const ok = confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å…³å¡æˆç»©å—ï¼Ÿ");
  if (!ok) return;

  await fetch("/api/reset", { method: "POST" });

  alert("å·²æ¸…ç©ºè¿›åº¦ï¼Œé‡æ–°å¼€å§‹é—¯å…³ï¼");
  await loadLevelsAndRender();   // é‡æ–°åŠ è½½å…³å¡çŠ¶æ€
});

  let levels = [];
  let currentLevelId = null;

  // typedChars stores ONLY characters for 'input' slots (letters/numbers)
  let typedChars = [];
  // é€šè¿‡ id æ‰¾åˆ°å…³å¡å¯¹è±¡
function getLevelById(id) {
  return levels.find(lv => lv.id === id);
}

// åŠ¨æ€è®¾ç½® audioï¼ˆå…³é”®ï¼šaudio.load()ï¼‰
function setAudio(path) {
  audio.innerHTML = "";     // audio æ˜¯ä½ ä¸Šé¢ const audio = document.getElementById("audio")
  if (!path) return;

  const src = document.createElement("source");
  src.src = STATIC_BASE + path;// DB: audio/l1.mp3 -> /static/audio/l1.mp3
  src.type = "audio/mpeg";

  audio.appendChild(src);
  audio.load();
}

  // -------------------------
  // 0.1) Helpers for template
  // -------------------------
  function isPunctuation(ch) {
    return !(/\p{L}|\p{N}/u.test(ch)) && !(/\s/u.test(ch));
  }

  function buildTemplateFromReference(refRaw) {
    const chars = Array.from(refRaw);
    const tpl = [];
    for (const ch of chars) {
      if (ch === " ") tpl.push({ type: "space" });
      else if (isPunctuation(ch)) tpl.push({ type: "punc", ch });
      else tpl.push({ type: "input" });
    }
    return tpl;
  }

  function getReferenceRaw() {
    return (referenceTextEl.textContent || "").trim();
  }

  function countInputSlots(template) {
    return template.reduce((acc, t) => acc + (t.type === "input" ? 1 : 0), 0);
  }

  function buildUserRawFromTyped(template, refRaw) {
    const refChars = Array.from(refRaw);
    let k = 0;
    const out = [];

    for (let i = 0; i < template.length; i++) {
      const t = template[i];
      if (t.type === "space") out.push(" ");
      else if (t.type === "punc") out.push(refChars[i] || t.ch || "");
      else {
        out.push(typedChars[k] || "");
        k++;
      }
    }
    return out.join("");
  }

  function isAllowedInputChar(ch) {
    return /\p{L}|\p{N}/u.test(ch);
  }

  // -------------------------
  // Render grid with caret at next input cell
  // -------------------------
  function renderGrid() {
    const refRaw = getReferenceRaw();
    const template = buildTemplateFromReference(refRaw);

    letterGrid.innerHTML = "";

    const totalInputs = countInputSlots(template);
    const caretInputIndex = Math.min(typedChars.length, totalInputs);

    let inputSlotIndex = 0;

    for (const t of template) {
      if (t.type === "space") {
        const s = document.createElement("span");
        s.className = "cell space";
        letterGrid.appendChild(s);
        continue;
      }

      const cell = document.createElement("span");
      cell.className = "cell";

      if (t.type === "punc") {
        cell.classList.add("punc");
        cell.textContent = t.ch || "";
      } else {
        const v = typedChars[inputSlotIndex] || "";
        if (!v) cell.classList.add("empty");
        cell.textContent = v;

        if (inputSlotIndex === caretInputIndex) cell.classList.add("caret");
        inputSlotIndex++;
      }

      letterGrid.appendChild(cell);
    }
  }

  function focusTyping() {
    hiddenInput.focus();
  }

  function attachTypingHandlers() {
    letterGrid.addEventListener("click", focusTyping);
    letterGrid.addEventListener("keydown", () => focusTyping());

    hiddenInput.addEventListener("keydown", (e) => {
      const refRaw = getReferenceRaw();
      const template = buildTemplateFromReference(refRaw);
      const maxLen = countInputSlots(template);

      if (e.key === "Backspace") {
        e.preventDefault();
        typedChars.pop();
        renderGrid();
        return;
      }

      if (e.key === "Enter") {
        e.preventDefault();
        document.getElementById("btnCheck").click();
        return;
      }

      // Ignore spaces
      if (e.key === " ") {
        e.preventDefault();
        return;
      }

      if (e.key.length === 1) {
        if (!isAllowedInputChar(e.key)) {
          e.preventDefault();
          return;
        }
        if (typedChars.length >= maxLen) {
          e.preventDefault();
          return;
        }
        e.preventDefault();
        typedChars.push(e.key);
        renderGrid();
      }
    });
  }

  // -------------------------
  // 1) Audio Controls
  // -------------------------

  document.getElementById("btnPlay").addEventListener("click", () => {
    audio.currentTime = 0;
    audio.play().catch(() => {
      alert("éŸ³é¢‘æ— æ³•æ’­æ”¾ï¼šè¯·ç¡®è®¤ static/audio/ ä¸‹æœ‰å¯¹åº” mp3ï¼Œä¸” levels.audio è·¯å¾„æ­£ç¡®ã€‚");
    });
  });

  document.getElementById("btnClear").addEventListener("click", () => {
    typedChars = [];
    renderGrid();
    focusTyping();
  });
  


  // æ ‡å‡†ç­”æ¡ˆé»˜è®¤éšè— + toggle
  const btnToggleRef = document.getElementById("btnToggleRef");
  btnToggleRef.addEventListener("click", () => {
    const hidden = referenceTextEl.classList.toggle("hidden");
    btnToggleRef.textContent = hidden ? "ğŸ‘ æ˜¾ç¤ºæ ‡å‡†ç­”æ¡ˆ" : "ğŸ™ˆ éšè—æ ‡å‡†ç­”æ¡ˆ";
  });

  // -------------------------
  // 2) Normalization + tokenization
  // -------------------------
  function normalizeToken(token) {
    return token
      .toLowerCase()
      .replace(/[^\p{L}\p{N}]+/gu, "");
  }

  function tokenizeSentence(sentence) {
    return sentence
      .trim()
      .split(/\s+/)
      .map(normalizeToken)
      .filter(t => t.length > 0);
  }

  // -------------------------
  // 3) LCS alignment (token-level)
  // -------------------------
  function alignTokens(ref, user) {
    const n = ref.length, m = user.length;
    const dp = Array.from({length: n+1}, () => Array(m+1).fill(0));

    for (let i = n - 1; i >= 0; i--) {
      for (let j = m - 1; j >= 0; j--) {
        if (ref[i] === user[j]) dp[i][j] = 1 + dp[i+1][j+1];
        else dp[i][j] = Math.max(dp[i+1][j], dp[i][j+1]);
      }
    }

    const ops = [];
    let i = 0, j = 0;
    while (i < n && j < m) {
      if (ref[i] === user[j]) {
        ops.push({ type: "ok", ref: ref[i], user: user[j] });
        i++; j++;
      } else {
        if (dp[i+1][j] >= dp[i][j+1]) {
          ops.push({ type: "missing", ref: ref[i] });
          i++;
        } else {
          ops.push({ type: "extra", user: user[j] });
          j++;
        }
      }
    }
    while (i < n) ops.push({ type: "missing", ref: ref[i++] });
    while (j < m) ops.push({ type: "extra", user: user[j++] });
    return ops;
  }

  function postProcessWrong(ops) {
    const out = [];
    let pendingMissing = null;

    for (const op of ops) {
      if (op.type === "missing") {
        if (pendingMissing) out.push(pendingMissing);
        pendingMissing = op;
      } else if (op.type === "extra") {
        if (pendingMissing) {
          out.push({ type: "wrong", ref: pendingMissing.ref, user: op.user });
          pendingMissing = null;
        } else {
          out.push(op);
        }
      } else {
        if (pendingMissing) { out.push(pendingMissing); pendingMissing = null; }
        out.push(op);
      }
    }
    if (pendingMissing) out.push(pendingMissing);
    return out;
  }

  // -------------------------
  // 4) Check + render results + POST attempt
  // -------------------------
  const resultSummary = document.getElementById("resultSummary");
  const resultTokens = document.getElementById("resultTokens");
  const refTokensView = document.getElementById("refTokensView");
  const userTokensView = document.getElementById("userTokensView");

  async function postAttempt(payload) {
    const res = await fetch("/api/attempt", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(payload)
    });
    if (!res.ok) {
      const t = await res.text();
      console.error("POST /api/attempt failed:", t);
    }
  }

  function currentLevel() {
    return levels.find(l => l.id === currentLevelId);
  }

  document.getElementById("btnCheck").addEventListener("click", async () => {
    const lv = currentLevel();
    if (!lv) return;

    const referenceRaw = getReferenceRaw();
    const template = buildTemplateFromReference(referenceRaw);
    const userRaw = buildUserRawFromTyped(template, referenceRaw);

    const refTokens = tokenizeSentence(referenceRaw);
    const usrTokens = tokenizeSentence(userRaw);

    refTokensView.textContent = refTokens.join(" | ");
    userTokensView.textContent = usrTokens.join(" | ");

    const ops = alignTokens(refTokens, usrTokens);
    const ops2 = postProcessWrong(ops);

    let ok = 0, wrong = 0, missing = 0, extra = 0;
    for (const op of ops2) {
      if (op.type === "ok") ok++;
      else if (op.type === "wrong") wrong++;
      else if (op.type === "missing") missing++;
      else if (op.type === "extra") extra++;
    }

    const totalRef = refTokens.length;
    const accuracy = totalRef === 0 ? 0 : Math.round((ok / totalRef) * 100);

    resultSummary.innerHTML =
      `Accuracyï¼ˆæŒ‰ reference è®¡ï¼‰: <b>${accuracy}%</b> ï½œ ` +
      `correct: <b>${ok}</b> ï½œ wrong: <b>${wrong}</b> ï½œ missing: <b>${missing}</b> ï½œ extra: <b>${extra}</b> ï½œ ` +
      `Pass score: <b>${lv.pass_score}%</b>`;

    resultTokens.innerHTML = "";
    for (const op of ops2) {
      const span = document.createElement("span");
      span.className = "tok " + op.type;

      if (op.type === "ok") {
        span.textContent = op.user;
        span.title = "correct";
      } else if (op.type === "wrong") {
        span.textContent = `${op.user} â†’ (${op.ref})`;
        span.title = `wrong (your: ${op.user}, ref: ${op.ref})`;
      } else if (op.type === "missing") {
        span.textContent = `(${op.ref})`;
        span.title = "missing";
      } else if (op.type === "extra") {
        span.textContent = op.user;
        span.title = "extra";
      }
      resultTokens.appendChild(span);
    }

    // å†™å…¥ DB
    await postAttempt({
      level_id: lv.id,
      accuracy,
      ok, wrong, missing, extra
    });

    // é€šè¿‡åˆ™å°è¯•è§£é”ä¸‹ä¸€å…³ï¼ˆåˆ·æ–°å…³å¡åˆ—è¡¨ï¼‰
    const passedNow = accuracy >= lv.pass_score;
    if (passedNow) {
      alert(`ğŸ‰ é€šè¿‡ ${lv.title}ï¼(${accuracy}% >= ${lv.pass_score}%)`);
    } else {
      alert(`å†æ¥ä¸€æ¬¡ï¼š${accuracy}% / éœ€è¦ ${lv.pass_score}%`);
    }

    await loadLevelsAndRender(); // åˆ·æ–° best/passed çŠ¶æ€

    // å¦‚æœé€šè¿‡ï¼Œè‡ªåŠ¨åˆ‡æ¢åˆ°ä¸‹ä¸€å…³ï¼ˆå¦‚æœå­˜åœ¨ä¸”å·²è§£é”ï¼‰
    if (passedNow) {
      const idx = levels.findIndex(x => x.id === lv.id);
      const next = levels[idx + 1];
      if (next) {
        // è§£é”è§„åˆ™ï¼šå‰ä¸€å…³ passed æ‰èƒ½ç©ä¸‹ä¸€å…³
        const nextUnlocked = levels[idx].passed; // åˆ·æ–°åå½“å‰å…³å·² passed
        if (nextUnlocked) {
          setCurrentLevel(next.id);
        }
      }
    }
  });

  // -------------------------
  // 5) Level loading + locking
  // -------------------------
  function isUnlocked(levelId) {
    const idx = levels.findIndex(l => l.id === levelId);
    if (idx <= 0) return true; // Level 1 always unlocked
    return levels[idx - 1].passed; // previous passed
  }

  function renderLevelSelect() {
    levelSelect.innerHTML = "";
    for (const lv of levels) {
      const opt = document.createElement("option");
      const unlocked = isUnlocked(lv.id);
      opt.value = String(lv.id);
      opt.disabled = !unlocked;

      const best = (lv.best_accuracy === null || lv.best_accuracy === undefined) ? "-" : lv.best_accuracy + "%";
      const status = lv.passed ? "âœ…" : (unlocked ? "ğŸ”“" : "ğŸ”’");
      opt.textContent = `${status} ${lv.title} (best: ${best})`;
      levelSelect.appendChild(opt);
    }
  }

  function setCurrentLevel(levelId) {
    currentLevelId = levelId;
    levelSelect.value = String(levelId);

    const lv = currentLevel();
    if (!lv) return;

    // å…³å¡æ–‡æœ¬ + éŸ³é¢‘
    referenceTextEl.textContent = lv.text;
    setAudio(lv.audio);

    // meta
    const best = (lv.best_accuracy === null || lv.best_accuracy === undefined) ? "-" : lv.best_accuracy + "%";
    levelMeta.textContent = `å½“å‰ï¼š${lv.title} ï½œ é€šè¿‡çº¿ï¼š${lv.pass_score}% ï½œ æœ€ä½³ï¼š${best} ï½œ çŠ¶æ€ï¼š${lv.passed ? "å·²é€šè¿‡" : "æœªé€šè¿‡"}`;

    // reset input/result
    typedChars = [];
    document.getElementById("resultSummary").textContent = "";
    document.getElementById("resultTokens").innerHTML = "";
    document.getElementById("refTokensView").textContent = "";
    document.getElementById("userTokensView").textContent = "";

    renderGrid();
    focusTyping();
  }

  async function loadLevelsAndRender() {
    const res = await fetch("/api/levels");
    levels = await res.json();

    // å¦‚æœé¦–æ¬¡è¿›å…¥ï¼Œé»˜è®¤é€‰ç¬¬ä¸€å…³ï¼›å¦åˆ™ä¿æŒå½“å‰
    if (!currentLevelId) currentLevelId = levels[0]?.id ?? null;

    renderLevelSelect();

    // è‹¥å½“å‰å…³è¢«é”äº†ï¼ˆæ¯”å¦‚æ‰‹åŠ¨æ”¹ DBï¼‰ï¼Œå¼ºåˆ¶å›åˆ°ç¬¬ä¸€å…³æˆ–ç¬¬ä¸€ä¸ªè§£é”å…³
    if (currentLevelId && !isUnlocked(currentLevelId)) {
      const firstUnlocked = levels.find(l => isUnlocked(l.id));
      currentLevelId = firstUnlocked ? firstUnlocked.id : levels[0]?.id;
    }

    if (currentLevelId) setCurrentLevel(currentLevelId);
  }

  levelSelect.addEventListener("change", (e) => {
    const id = parseInt(e.target.value, 10);
    setCurrentLevel(id);
  });

  // -------------------------
  // Init
  // -------------------------
  attachTypingHandlers();
  loadLevelsAndRender().then(() => {
    // æ ‡å‡†ç­”æ¡ˆé»˜è®¤éšè—ï¼ˆæŒ‰é’®æ–‡å­—å·²æ˜¯â€œæ˜¾ç¤ºâ€ï¼‰
    referenceTextEl.classList.add("hidden");
    renderGrid();
    focusTyping();
  });
</script>
</body>
</html>
